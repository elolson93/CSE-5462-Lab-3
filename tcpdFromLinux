1 #include <stdio.h>
  2 #include <strings.h>
  3 #include <string.h>
  4 #include <stdlib.h>
  5 #include <sys/types.h>
  6 #include <sys/socket.h>
  7 #include <sys/select.h>
  8 #include <netinet/in.h>
  9 #include <arpa/inet.h>
 10 #include <netdb.h>
 11 #define MSS 1000
 12 #define LOCAL_TCPD_PORT 9999
 13 #define REMOTE_TCPD_PORT 8888
 14 #define LOCAL_ADDRESS "127.0.0.1"
 15 
 16 
 17 int main(int argc, char *argv[])
 18 {
 19 
 20     /* Set up the sockets for local and remote communication */
 21         int local_sock;
 22         int remote_sock;
 23 
 24     struct sockaddr_in local_name;
 25     struct sockaddr_in remote_name;
 26 
 27     /*create local port*/
 28     local_sock = socket(AF_INET, SOCK_DGRAM, 0);
 29     if(local_sock < 0) {
 30            perror("opening local datagram socket");
 31            exit(1);
 32         }
 33 
 34     local_name.sin_family = AF_INET;
 35     local_name.sin_port = LOCAL_TCPD_PORT;
 36     local_name.sin_addr.s_addr = inet_addr(LOCAL_ADDRESS);
 37 
 38     if(bind(local_sock, (struct sockaddr *)&local_name, sizeof(local_name)) < 0) {
 39         perror("getting local socket name");
 40         exit(2);
 41     }
 42 
 43     printf("%s\n", "Local socket bound");
 44 
 45     /*create remote port*/
 46     remote_sock = socket(AF_INET, SOCK_DGRAM, 0);
 47     if(remote_sock < 0) {
 48            perror("opening remote datagram socket");
 49            exit(1);
 50         }
 51     remote_name.sin_family = AF_INET;
 52     remote_name.sin_port = REMOTE_TCPD_PORT;
 53     remote_name.sin_addr.s_addr = inet_addr(LOCAL_ADDRESS);
 54 
 55     if(bind(remote_sock, (struct sockaddr *)&remote_name, sizeof(remote_name)) < 0) {
 56            perror("getting remote socket name");
 57            exit(1);
 58     }
 59 
 60     printf("%s\n", "Remote socket bound.");
 61 
 62 
/* If this is running on the client, set up the remote port*/
 64     struct sockaddr_in remote_server_tcpd;
 65     struct sockaddr_in local_server_name;
 66         struct hostent *hp, *gethostbyname();
 67 //    if (strcmp(argv[1], "1") == 0) {
 68 
 69         hp = gethostbyname(argv[2]);
 70         bcopy((void *)hp->h_addr, (void *)&remote_server_tcpd.sin_addr, hp->h_length);
 71 
 72         remote_server_tcpd.sin_family = AF_INET;
 73         remote_server_tcpd.sin_port = htons(REMOTE_TCPD_PORT);
 74         //remote_server_tcpd.sin_addr.s_addr = inet_addr(argv[2]);
 75         printf("%s\n", "Set up remote tcpd information");
 76   //  } else if (strcmp(argv[1], "0") == 0) {
 77         local_server_name.sin_family = AF_INET;
 78         local_server_name.sin_port = -1;
 79         local_server_name.sin_addr.s_addr = inet_addr(LOCAL_ADDRESS);
 80   //  } else {
 81        // printf("%s\n", "Encountered an invalid argument. Not a 0 or a 1.");
 82        /// exit(1);
 83   //  }
 84 
 85     printf("%s\n", "After the type check");
 86 
 87     //set for holding remote and local sockets to listen to
 88     fd_set readfds;
 89     //buffers to hold data sent to or received from the local and remote sockets
 90     char local_buf[MSS] = {0}, remote_buf[MSS] = {0};
 91     //to keep track of the maximum amount of data the server can accept
 92     int ftpsMaxData = -1;
 93     int serverPort = -1;
 94     //to keep track of the amount of data received
 95     int amtRecvd = 0;
 96 
 97     while(1) {
 98 printf("%s\n", "In the while");
 99         // clear the set 
100         FD_ZERO(&readfds);
101 
102         // add our descriptors to the set
103         FD_SET(local_sock, &readfds);
104         FD_SET(remote_sock, &readfds);
105 
106         // Block until input arrives on one or more sockets
107         if(select(FD_SETSIZE, &readfds, NULL, NULL, NULL) < 0) {
108             fprintf(stderr, "%s\n", "There was an issue with select() in tcpd");
109             exit(1);
110         }
111         printf("%s\n", "Got something from a socket");
112         //Grab data from any socket that is ready
113         if (FD_ISSET(local_sock, &readfds)) {
114             //receive data from the local socket
115             amtRecvd = recvfrom(local_sock, local_buf, sizeof(local_buf), 0, NULL, NULL);
116 
117             printf("%s: %d %s\n", "received data from the local socket", amtRecvd, local_buf);
118 
119             if (local_buf[0] == '1') {
120                 //forward the data to the remote tcpd through troll
121                 printf("%s\n", "Just received a message from the client");
122 
123                 //remove the header
124                 //char *local_buf_no_header = local_buf + 1;
125                 //memmove(local_buf, local_buf+1, strlen(local_buf+1)+1);
126                 //printf("%s\n", local_buf_no_header);
127                 printf("Local buf contents: %s\n", local_buf);
128 
129                 char testArray[10] = {'h'};
130 
131                 if( sendto(remote_sock, testArray, 10, 0,
132                     (struct sockaddr *)&remote_server_tcpd, sizeof(remote_server_tcpd)) < 0) {
133 
134                 perror("Failed to send to remote tcpd");
135                 }
136 
137             } else if (local_buf[0] == '0') {
138                 printf("%s\n", "Just received a message from the server");
139 
140                 int* max_length = (int*)(&local_buf[1]);
141                 ftpsMaxData = *max_length;
142 
143                 int* port_value = (int*)(&local_buf[5]);
144                 serverPort = *port_value;
145                 local_server_name.sin_port = htons(serverPort);
146 
147                 printf("MAX DATA: %d, PORT: %d\n", ftpsMaxData, serverPort);
148 
149              } else {
150                 fprintf(stderr, "%s\n", "Message from unknown source");
151                  exit(1);
152              }
153         }
154         if (FD_ISSET(remote_sock, &readfds)) {
155             //receive data from the remote socket
156             amtRecvd = recvfrom(remote_sock, remote_buf, sizeof(remote_buf), 0, NULL, NULL);
157 
158             printf("%s%d\n", "Just received data on the remote socket: ", amtRecvd);
159             printf("%s\n", remote_buf);
160 
161             //forward data up to ftps
162           //  if (NULL == local_server_name) {
163           //      fprintf(stderr, "%s\n", "The server is not ready for packets");
164            //     exit(1);
165            // } else {
166                 if (sendto(remote_sock, remote_buf, amtRecvd, 0, (struct sockaddr *)&local_server_name, sizeof(local_server_name)) < 0) {
167                     fprintf(stderr, "%s\n", "Error sending to server from local tcpd");
168                     exit(1);
169                 }
170             //}
171         }
172     } // end while
